#pragma kernel CSMain
static const int threadGroupSize = 1024;

struct Boid {
    float3 position;
    float3 direction;
    
    float3 flockDirection;
    float3 flockCenter;
    float3 separationDirection;
    int numFlockmates;
    int isAlive;
    int goalReached;
};

struct Neighbor {
    uint boidIdx;
    float3 position;
};

RWStructuredBuffer<Boid> boids;
RWStructuredBuffer<Neighbor> neighbors;
RWStructuredBuffer<float3> potentialField;

int numBoids;
int maxNeighbors;
float neighborMaxDist;
float desiredDist;
float goalRadius;

int isField;
int3 gridSize;
float3 cellSize;
float3 gridStart;
float3 targetPos;

uint CoordinateToIndex(int3 pos) {
    uint coordinateIdx = pos.x + pos.y * gridSize.x + pos.z * gridSize.x * gridSize.y;
    return coordinateIdx;
}

[numthreads(threadGroupSize, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    Boid currBoid = boids[id.x];
    currBoid.numFlockmates = 0;
    if (currBoid.isAlive == 1 && currBoid.goalReached == 0){
        if (length(targetPos - currBoid.position) < goalRadius) {
            currBoid.goalReached = 1;
        }
        else {
            int startIdx = id.x * maxNeighbors;
            for (uint indexBoid = 0; indexBoid < numBoids; indexBoid++) {
                if (id.x != indexBoid) {
                    Boid boidI = boids[indexBoid];
                    if (boidI.goalReached == 0) {
                        if (all(boidI.position != float3(0,0,0))) {
                            float3 offset = boidI.position - currBoid.position;
                            float sqrDist = offset.x * offset.x + offset.y * offset.y + offset.z * offset.z;

                            //Checks for neighboring boids within a set radius of the current boid
                            if (sqrDist < neighborMaxDist * neighborMaxDist) {
                                Neighbor n;
                                n.boidIdx = id.x;
                                n.position = boidI.position;
                                neighbors[startIdx + currBoid.numFlockmates] = n;
                                currBoid.numFlockmates += 1;
                                currBoid.flockDirection += boidI.direction;
                                currBoid.flockCenter += boidI.position;

                                if (sqrDist < desiredDist * desiredDist) {
                                    currBoid.separationDirection -= offset;
                                }
                            }
                        }
                    }
                }
            }
            if (isField == 1) {
                //int3 boidGridIdx = int3(floor((currBoid.position - gridStart) / cellSize));
                //uint gridIndex = CoordinateToIndex(boidGridIdx);
                int3 boidGridIdx = int3(
                    floor((currBoid.position.x - gridStart.x)/cellSize.x),
                    floor((currBoid.position.y - gridStart.y)/cellSize.y),
                    floor((currBoid.position.z - gridStart.z)/cellSize.z)
                );
                uint gridIndex = boidGridIdx.x + boidGridIdx.y * gridSize.x + boidGridIdx.z * gridSize.x * gridSize.y;
                currBoid.flockDirection = potentialField[gridIndex];
            }
        }
    }
    boids[id.x] = currBoid;
}